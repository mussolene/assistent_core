# План развития Assistant Core

Документ описывает направления развития: **покрытие тестами (максимальный приоритет)**, многопользовательский режим с авторизацией, упрощённое спаривание Telegram, доработка Dashboard (мониторинг, динамика, команды бота, роли, первичная инициализация).

---

## 0. Покрытие тестами (максимальный приоритет)

**Статус:** цель **90%** достигнута; в `pyproject.toml` установлено `fail_under = 90`. Отдельные модули (file_indexing, email_adapter) остаются ниже — опционально добивать в следующих итерациях.

### Цель

- Довести покрытие тестами до **90%** по коду, участвующему в отчёте (исключая точки входа и адаптеры по соглашению).
- Покрыть **весь функционал, который возможно покрыть** unit- и интеграционными тестами.
- **Никогда не подстраивать тесты под поведение:** если тест выявил баг — исправлять код, а не ослаблять/менять тест. Обязательна **двойная проверка функциональности** (ожидаемое поведение по спецификации/документации, а не «как сейчас работает»).
- Попутно **исправлять баги**, выявленные тестами.

### Принципы

| Принцип | Описание |
|--------|----------|
| **Тест — источник истины** | Тест формулирует ожидаемое поведение. Если код ведёт себя иначе — меняем код, не тест. |
| **Двойная проверка** | Перед фиксацией «ожидания» в тесте: проверить по AGENTS.md, контрактам API, здравому смыслу. Не закреплять ошибочное поведение. |
| **Баг → фикс в коде** | Падающий тест из-за бага в продуктивном коде — исправлять продуктивный код; не ослаблять assertion и не подгонять тест под баг. |
| **Покрытие без «мусорных» тестов** | Тесты должны проверять осмысленные сценарии и граничные случаи, а не просто увеличивать процент покрытия. |

### Целевой показатель

- **Цель покрытия:** 90% (в `pyproject.toml`: `fail_under = 90` после достижения).
- **Текущий порог** может быть ниже (например 77%) до завершения этапов; по мере роста покрытия порог поднимать.

### Этапы (разбивка по модулям и типам функционала)

Разбивка такова, чтобы по шагам покрыть весь тестируемый функционал; на каждом этапе — при необходимости исправление багов, выявленных тестами.

| Этап | Модули / функционал | Что покрыть | Примечание |
|------|----------------------|------------|------------|
| **T1. Core: оркестратор и поток задач** | `orchestrator`, `bus`, `task_manager` | Обработка входящих сообщений, аттачменты, «только вопрос о файле», формирование контекста, вызов агентов, поток событий (publish/subscribe), граничные случаи (пустой текст, только файл). | Моки Redis, gateway, memory; не подстраивать тесты под текущие баги. |
| **T2. Core: файлы и индексация** | `file_indexing` | Извлечение текста (txt, csv, html, md, xlsx, pdf, docx), архивы (zip, tar, gz, 7z, rar), path traversal, chunking, `index_telegram_attachments` (с моками HTTP/Redis), get/list file_ref. | Уже частично покрыто; добавить ветки 7z/rar при наличии библиотек, ошибки чтения, лимиты. |
| **T3. Core: память и уведомления** | `memory/manager`, `short_term`, `notify` | Добавление/получение контекста, short-term окно, векторная память (моки), сжатие; notify: все ветки (pending confirmation, dev feedback, ошибки Redis). | Проверить контракты и исправить баги при расхождении. |
| **T4. Агенты** | `assistant`, `tool_agent`, `base` | Парсинг tool_calls, вызов gateway (streaming/не streaming), обработка ошибок модели; tool_agent: пустые tool_calls, неизвестный skill, нормализация params (в т.ч. tasks). | Не менять тесты под «удобное» поведение при ошибках. |
| **T5. Skills: registry, runner, базовые скиллы** | `registry`, `runner`, `filesystem`, `checklist`, `file_ref`, `memory_control`, `mcp_adapter` | Регистрация, run неизвестного skill, sandbox runner; каждый скилл: все action и граничные случаи (пустые параметры, ошибки). | file_ref, checklist уже частично покрыты; добить ветки. |
| **T6. Skills: tasks и git** | `tasks`, `git_platform` | Tasks: все action (create, list, remind, done и т.д.) с моками Redis; граничные случаи дат, напоминаний. Git: клонирование, статус, коммит с моками (или изолированный репозиторий). | Высокая плотность логики; баги фиксировать по мере выявления. |
| **T7. Модели и конфиг** | `models/gateway`, `local`, `config/loader` | Вызов generate (stream/no stream), fallback, ошибки сети; загрузка конфига из файла и env, валидация. | |
| **T8. Безопасность и audit** | `security/command_whitelist`, `audit`, `skills/runner` | Whitelist команд, запрет опасных команд; audit log; изоляция runner. | |
| **T9. Dashboard и MCP (по возможности)** | `dashboard` (API, без рендера), `mcp_*` | API мониторинга, сохранение настроек, MCP endpoints (с моками). | Часть кода может быть исключена из отчёта покрытия. |

### Порядок выполнения

1. Выполнять этапы **T1 → T9** последовательно (при необходимости менять порядок только для зависимостей).
2. На каждом этапе: писать/дополнять тесты, запускать покрытие, **исправлять выявленные баги в коде**, при сомнениях в ожидании — сверяться с документацией и контрактами.
3. После каждого этапа поднимать `fail_under` в `pyproject.toml` только когда текущее покрытие стабильно выше нового порога.
4. Финал: покрытие ≥ 90%, `fail_under = 90`, все тесты зелёные, баги, найденные тестами, исправлены.

---

## 1. Многопользовательский режим с авторизацией

### Цель

- Разделение пользователей Dashboard: несколько учётных записей с логином/паролем или OAuth.
- Роли: владелец (admin), оператор, наблюдатель — с разным доступом к разделам и командам.
- Сессии и защита от несанкционированного доступа.

### Варианты реализации

| Вариант | Плюсы | Минусы |
|--------|--------|--------|
| **Локальные логин/пароль в Redis** | Без внешних зависимостей, просто | Нет восстановления пароля, свои хеши |
| **JWT + Redis (users, sessions)** | Stateless API, подходит для SPA | Нужна страница логина и refresh |
| **OAuth2 (Google/GitHub)** | Привычный вход, не храним пароли | Зависимость от провайдера, настройка |
| **Единый «мастер-пароль» + коды доступа** | Минимум кода | Один пароль на всех, слабая гранулярность |

**Рекомендация для MVP:** локальные пользователи в Redis (таблица `assistant:users`: login, password_hash, role, created_at) + сессии в Redis (`assistant:session:<sid>`). Роли: `owner`, `operator`, `viewer`. Позже — опциональный OAuth.

### Задачи

1. **Модель пользователя и хранилище**
   - Ключи Redis: `assistant:users`, `assistant:user:<login>`, `assistant:session:<session_id>`.
   - Поля: login, password_hash (bcrypt/argon2), role, display_name, created_at.
   - Функции: create_user, get_user, verify_password, update_password.

2. **Сессии**
   - При успешном логине: создать session_id (uuid), записать в Redis с TTL (например 24h), в cookie — httpOnly, secure при HTTPS.
   - Middleware/декоратор: требовать авторизацию для всех маршрутов кроме `/login`, `/setup`, `/api/health`.

3. **Роли и доступ**
   - `owner`: полный доступ, настройка пользователей, первичная инициализация уже пройдена.
   - `operator`: Telegram, модель, MCP, мониторинг; команды бота по разрешениям; без управления пользователями.
   - `viewer`: только мониторинг и просмотр (read-only) настроек.

4. **Интеграция с текущим Dashboard**
   - Страница `/login` (редирект на неё при отсутствии сессии).
   - В шапке: текущий пользователь, роль, «Выйти».
   - Проверка роли перед рендером секций и перед каждым API (save-telegram, save-model и т.д.).

5. **Миграция текущего состояния**
   - Если пользователей ещё нет и включён «режим первой настройки» (см. раздел 5) — показывать wizard создания первого пользователя (owner). После этого все заходы — только через логин.

---

## 2. Спаривание Telegram: быстрая привязка без лишних шагов

### Текущее поведение

- В Dashboard включают «Pairing», потом в Telegram отправляют `/start` или `/pair` — ID добавляется в whitelist. Минус: нужно заходить в Dashboard и включать режим, потом идти в бота.

### Цель

Человек заходит в Dashboard (или открывает «страницу привязки») и за 1–2 действия привязывает свой Telegram без поиска настроек.

### Варианты быстрого спаривания

| Способ | Как работает | Плюсы | Минусы |
|--------|--------------|--------|--------|
| **Код в сообщении** | В Dashboard показываем 6-значный код (например `482917`), действует 5–10 мин. Пользователь пишет боту `/start 482917` или `@bot /pair 482917`. Бот проверяет код в Redis, добавляет user_id. | Не нужен QR, работает с любого устройства | Нужно ввести код вручную |
| **Magic-ссылка в Telegram** | Генерируем deep link `https://t.me/BotName?start=payload`, где payload = одноразовый токен. Пользователь жмёт ссылку в Dashboard — открывается Telegram с уже подставленным start. Бот получает `start payload`, привязывает. | Один клик из браузера | Нужно передать токен в ссылку и хранить в Redis до использования |
| **QR-код** | На странице «Привязать Telegram» показываем QR с ссылкой `https://t.me/BotName?start=<token>`. Пользователь сканирует телефоном. | Удобно с телефона | Лишний шаг, если пользователь уже в браузере на телефоне |
| **Комбинация: код + ссылка** | На одной странице: короткий код (для тех, кто уже в Telegram) и кнопка «Открыть в Telegram» (magic-ссылка). | Гибко | Немного больше UI |

**Рекомендация:** комбинация **код + magic-ссылка**.

### Реализация (код + ссылка)

1. **Страница «Привязать Telegram»** (доступна по отдельной ссылке, например `/pair-telegram`, и из раздела Telegram в Dashboard).
   - Кнопка «Сгенерировать код и ссылку».
   - Backend: создать запись в Redis `assistant:pairing:<code>` со значением `{ "created_at": ts, "used": false }`, TTL 600 сек (10 мин). Код — 6 цифр или буквенно-цифровой короткий токен.
   - Показать пользователю:
     - Код: «Отправьте боту в Telegram: `/start КОД` или `/pair КОД`».
     - Кнопка/ссылка: «Открыть в Telegram» → `https://t.me/<bot_username>?start=<code>` (если известен username из getMe) или просто инструкция с кодом.

2. **Бот**
   - При сообщении `/start` или `/pair`:
     - Если есть аргумент (например `/start 482917`): извлечь код, проверить в Redis `assistant:pairing:<code>`. Если есть и не used — добавить user_id в TELEGRAM_ALLOWED_USER_IDS, пометить код использованным, ответить «Привязка выполнена».
     - Если аргумента нет и включён глобальный Pairing Mode (как сейчас) — поведение как сейчас (добавить в whitelist по факту /start).
   - Таким образом сохраняется обратная совместимость: старый сценарий «включили Pairing в Dashboard и написали /start» по-прежнему работает.

3. **Безопасность**
   - Код одноразовый и с TTL.
   - Не логировать коды в открытом виде.
   - Опционально: привязка по коду разрешена только если пользователь Dashboard уже авторизован (и при необходимости — только роль owner/operator).

### Задачи

1. API: `POST /api/pairing-code` — создаёт код и возвращает `{ code, link, expires_in_sec }`.
2. Redis: ключ `assistant:pairing:<code>`, TTL 600.
3. В адаптере Telegram: обработка `/start <code>` и `/pair <code>` — проверка кода, добавление в whitelist, ответ пользователю.
4. Страница Dashboard: блок «Быстрая привязка» с кнопкой «Сгенерировать», отображение кода и ссылки, таймер обратного отсчёта (опционально).

---

## 3. Dashboard: доработки интерфейса и возможностей

### 3.1 Информативный мониторинг

**Сейчас:** три карточки (память Redis, подключения, число ключей), обновление только при перезагрузке страницы.

**Цель:** больше метрик и контекста, чтобы понимать состояние системы.

- **Redis**
  - Память: used / peak / fragmentation; количество ключей по префиксам (`assistant:task:*`, `assistant:config:*`, `assistant:summary:*` и т.д.).
  - Подключения: connected_clients, blocked_clients.
  - Опционально: последние ключи (список с TTL) для отладки.
- **Сервисы**
  - Статус «живости»: опрос эндпоинтов (assistant-core health, telegram-adapter, модель — один запрос к OPENAI_BASE_URL или /health). Цвет/иконка: зелёный / жёлтый / красный.
  - Версии или время последнего ответа (если есть такие API).
- **Нагрузка (по возможности)**
  - Количество задач в очереди (по каналу Redis или по ключам `assistant:task:*` в статусе «в работе»).
  - Количество сообщений за последние N минут (если храним счётчики в Redis).

**Реализация**

- Расширить `_redis_info()` и API `/api/monitor`: возвращать структуру с блоками `redis`, `services`, `tasks`.
- Добавить эндпоинты здоровья в assistant-core и telegram-adapter (например `GET /health`), опрашивать их с Dashboard (с учётом CORS или через backend-proxy).
- На фронте (см. п. 3.2) — отображать карточки/таблицы по этим блокам.

### 3.2 Более асинхронный и динамичный интерфейс

**Сейчас:** классический server-rendered Flask: каждая кнопка/переход — полная перезагрузка или форма POST.

**Цель:** страницы обновляются без полной перезагрузки, есть индикаторы загрузки и плавные обновления данных.

- **Мониторинг**
  - Автообновление раз в N секунд (например 10): запрос `GET /api/monitor` через fetch, подстановка данных в DOM. Таймер/индикатор «обновлено N сек назад».
- **Формы (Telegram, модель, MCP)**
  - Отправка через fetch (`POST /save-telegram` и т.д.), ответ JSON (success/error). При успехе — показать уведомление, не обязательно редирект (или мягкий редирект на ту же страницу с сообщением).
  - Кнопки «Проверить бота» / «Проверить модель» — запрос к API, результат в том же блоке без перезагрузки (уже частично есть через fetch в текущем JS).
- **Единый слой JS**
  - Небольшой vanilla JS или лёгкий фреймворк (Alpine.js или Petite-Vue) для: таймеров, fetch, обновления блоков. Либо вынести общий `dashboard.js` с функциями `apiPost(url, body)`, `refreshMonitor()`, `showToast(msg)`.
- **Визуальная обратная связь**
  - При сохранении: кнопка «Сохранить» в состоянии loading (spinner), после ответа — краткое уведомление (toast или inline).
  - При ошибке — сообщение под формой или в общем блоке ошибок.

**Задачи**

1. Добавить `dashboard/static/js/app.js` (или встроить в шаблон): обёртки для fetch, обработка 401 (редирект на логин), toast/уведомления.
2. Мониторинг: страница с `setInterval(refreshMonitor, 10000)` и подстановкой данных в шаблон (или data-атрибуты + обновление текста).
3. Формы: по возможности перевести на `form.addEventListener('submit', async e => { e.preventDefault(); ... fetch(...) })` с отключением стандартной отправки для ключевых форм.

### 3.3 Больше возможностей и команд в Telegram-боте

**Реализовано:** `/status` — краткий статус (модель, число задач в очереди); `/restart` — только для пользователей из TELEGRAM_ADMIN_IDS (Redis), запись флага `assistant:action:restart_requested` в Redis; выполнение перезапуска — внешний скрипт/воркер (этап F).

**Сейчас:** /start, /help, /reasoning, /status, /restart и общий диалог с ассистентом.

**Цель:** административные/операционные команды, в том числе перезапуск кластера и управление, с разграничением по ролям (см. п. 3.4).

Примеры команд (идеи):

- **Для владельцев/операторов**
  - `/restart` или `/cluster_restart` — запрос на перезапуск сервисов (реализация: публикация события в Redis или вызов внутреннего API; отдельный worker или cron перезапускает контейнеры/процессы по флагу). Важно: подтверждение («Вы уверены? Ответьте да») или одноразовый код.
  - `/status` — краткий статус: модель подключена, очередь задач, версия (если есть).
  - `/logs` — последние N строк логов (только для owner; осторожно с секретами).
- **Для всех**
  - `/help` — расширенная справка с перечнем команд по ролям.
  - `/reasoning` — как сейчас.

**Реализация**

- В канале Telegram при получении сообщения: если текст — известная команда (например `/restart`), не отправлять в оркестратор как обычное сообщение, а вызвать обработчик команд.
- Обработчик команд:
  - Определить «роль» пользователя Telegram: по user_id сверить с таблицей пользователей Dashboard (или с отдельным списком `assistant:telegram_roles`: user_id → role). Если ролей в Dashboard ещё нет — можно временно по whitelist считать всех «user», а роль брать из Redis `assistant:telegram_admin_ids` (список ID с правами на админ-команды).
  - Для `/restart`: проверить роль, отправить в чат «Запрос на перезапуск отправлен. Подтвердите код XXXX» или «Подтвердите: да»; по подтверждению — записать в Redis `assistant:action:restart_requested` с user_id и timestamp; отдельный процесс/скрипт или webhook от системы оркестрации выполняет перезапуск и очищает флаг.
- Перезапуск кластера: вариант 1 — Docker API (если Dashboard/worker имеет доступ к Docker socket); вариант 2 — внешний скрипт или CI, который смотрит Redis на флаг и выполняет `docker compose restart`; вариант 3 — только «перезапуск воркеров» через сигнал или внутренний API (без полного перезапуска хоста).

**Задачи**

1. Вынести обработку команд из общего потока сообщений: блок «если текст в списке команд — вызвать command_handler, иначе — publish_incoming».
2. Реализовать команды: `/status`, `/restart` (с подтверждением), при необходимости `/logs` (только owner).
3. Хранение ролей для Telegram: либо связка user_id (Telegram) → user (Dashboard) при первом логине/привязке, либо отдельный ключ `assistant:telegram_roles` (user_id → role).
4. Механизм перезапуска: дизайн (Redis-флаг + скрипт или Docker API) и реализация в рамках выбранного варианта.

### 3.4 Разграничение команд по ролям

- В конфиге или в Redis: список команд и минимальная роль (например `restart` → owner, `status` → operator, `help` → все).
- При получении команды в боте: определить роль пользователя (см. п. 3.3), проверить разрешение, выполнить или ответить «Недостаточно прав».
- Синхронизация ролей: при привязке Telegram к пользователю Dashboard (логин + роль уже есть) — записать в Redis соответствие telegram_user_id → role. Если пока нет многопользовательского Dashboard — временная схема: в настройках Telegram ввести «админские ID» (список), остальные — обычные пользователи.

**Задачи**

1. Модель: команда → минимальная роль (таблица или конфиг).
2. В Telegram-адаптере: перед выполнением команды — проверка роли.
3. В UI Dashboard (после появления пользователей): привязка «Telegram ID ↔ пользователь (роль)» или настройка «админские Telegram ID».

### 3.5 Первоначальная инициализация панели (первый вход)

**Цель:** при первом заходе на Dashboard головной пользователь проходит короткую «установку»: создаёт первого владельца, при необходимости вводит коды верификации и базовые настройки.

**Сценарий**

1. При загрузке любого защищённого маршрута (или корня `/`) проверять: есть ли хотя бы один пользователь с ролью `owner` в Redis.
2. Если пользователей нет — редирект на `/setup` (страница первичной настройки). Маршруты `/setup` и `/setup/*` не требуют авторизации.
3. **Страница `/setup`**
   - Шаг 1: «Создание владельца» — логин, пароль, подтверждение пароля, опционально email для восстановления (на будущее).
   - Шаг 2 (опционально): «Верификация» — например ввод кода из email или из консоли (для self-hosted: вывести одноразовый код в stdout при первом запуске). Можно отложить и сделать только «подтвердите пароль ещё раз».
   - Шаг 3: «Базовые настройки» — Redis URL уже есть из env; опционально: Telegram token, чтобы сразу включить бота; или пропустить и настроить позже.
   - После успешного прохождения: создать пользователя owner в Redis, установить флаг `assistant:setup_done` = true, создать сессию и редирект на главную (Telegram или Мониторинг).
4. При последующих заходах: если `assistant:setup_done` и есть owner — показывать обычный логин; если сессии нет — редирект на `/login`.

**Верификация (опции)**

- **Код из консоли:** при первом запуске assistant-core или dashboard вывести в лог: «Setup code: XXXXXX». Пользователь вводит его на шаге 2. Код храним в Redis с TTL 1 час; после использования — удалить.
- **Инвайт-код:** заранее сгенерированный список кодов в Redis (assistant:invite_codes). Один код = одно создание owner (или один инвайт в систему). После ввода кода — код помечается использованным.
- **Без кода:** только надёжный пароль и подтверждение; для самопроверки — капча (опционально).

**Задачи**

1. Проверка при старте приложения/при каждом запросе: `setup_done` и наличие owner.
2. Маршруты: `GET /setup`, `POST /setup/owner`, `POST /setup/verify` (если есть шаг верификации), `POST /setup/finish`.
3. Страница `/setup`: многошаговая форма (или одна страница с блоками), валидация на клиенте и сервере.
4. Установка cookie сессии после успешного setup и редирект на главную.
5. Логирование события «первичная настройка выполнена» (audit).

---

## 4. Приоритизация и этапы

**Сначала** выполняются этапы **покрытия тестами (раздел 0, этапы T1–T9)** — максимальный приоритет. Затем — функциональные этапы ниже.

| Этап | Содержание | Зависимости |
|------|------------|-------------|
| **T1–T9. Покрытие тестами** | См. раздел **0**. Цель 90%, исправление багов по ходу, без подстройки тестов под поведение. | — |
| **A. Основа авторизации** | Модель пользователей и сессий в Redis, роли, middleware, страница логина, защита маршрутов. | — |
| **B. Первичная настройка** | Флаг setup_done, страница /setup, создание первого owner, редиректы. | A (или параллельно с A) |
| **C. Спаривание Telegram** | Код + magic-ссылка, API pairing-code, обработка /start &lt;code&gt; в боте. | — (можно раньше A) |
| **D. Мониторинг и динамика** | Расширенный /api/monitor, автообновление, health сервисов, улучшение форм (fetch + toast). | — |
| **E. Команды бота и роли** | Обработчик команд в Telegram, /status, /restart (с подтверждением), привязка ролей к user_id. | A |
| **F. Перезапуск кластера** | Реализация механизма (Redis-флаг + скрипт или Docker API). | E |

Рекомендуемый порядок: **T1 → T9** (тесты и баги), затем **A + B** (вход и первый пользователь), **C** (спаривание), **D** (мониторинг и динамика), **E + F** (команды и перезапуск).

---

## 5. Риски и ограничения

- **Перезапуск кластера из бота:** доступ к Docker или к хосту создаёт повышенные риски; обязательны подтверждение и аудит (кто и когда запросил). По возможности вынести в отдельный «контроллер» с минимальными правами.
- **Роли только в Redis:** при миграции на другую БД (Postgres) потребуется перенос схемы пользователей и сессий; заложить абстракцию хранилища (интерфейс UserStore/SessionStore) с реализацией под Redis.
- **Динамика в Dashboard:** при добавлении большого объёма JS учитывать совместимость с текущим server-side рендерингом (например не ломать работу без JS для базовых форм).

---

## 6. Связь с AGENTS.md и текущей архитектурой

- **Event Bus:** команды бота (например перезапуск) могут публиковать внутреннее событие `ClusterActionRequested`; отдельный подписчик (в том же процессе или отдельный worker) выполняет действие и логирует.
- **Security:** все новые эндпоинты (setup, login, pairing-code) — rate limit, audit логирование без секретов.
- **Конфиг:** список ролей и привязка команд к ролям — в Redis (управление через Dashboard) или в YAML с переопределением из Redis.

Документ можно обновлять по мере реализации этапов (отмечать выполненные пункты и переносить задачи в AUDIT или в issues).
